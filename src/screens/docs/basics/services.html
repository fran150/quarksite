    <span class="docs">
        <h1>Servicios y Contexto</h1>
        <hr />
        <p>
            Los servicios permiten definir una lógica de negocio para la aplicación y compartirla entre los distintos
            componentes. Los contextos permiten compartir estos servicios entre los componentes
            con el patrón <code>Singleton</code>. Los servicios definidos dentro de un contexto serán
            siempre un singleton, por lo que los componentes que compartan contexto estarán compartiendo
            todos los servicios definidos en el.
        </p>
        <p>
            Todos los componentes aceptan recibir un contexto de servicios en un parametro <code>context</code>.
            Este contexto es recibido en el modelo del componente como un cuarto parametro en el constructor,
            y se expone automáticamente en la propiedad <code>context</code>.
        </p>
        <p>
            Si un componente no recibe un contexto de algun padre crea uno propio. El desarrollador puede
            crear contextos de servicios manualmente utilizando el método
            <a data-bind="href: 'main/docs/refs-services-servicecontext'">$$.serviceContext</a>.
            Luego podra pasar el nuevo contexto a cualquier componente hijo como parametro context.
        </p>
        <p>
            Considere el siguiente componente:

            <code-highlight>
define(['quark', 'knockout', 'text!select.component.html'], function($$, ko, template) {
    function PersonsSelectComponent(params, $scope, $imports) {
        var self = this;

        $$.parameters({
            value: ko.observable()
        }, params, this);

        $scope.data = ko.observableArray();

        function read() {
            $$.ajax('http://example.com/persons', 'GET', {}, {
                onSuccess: function(data) {
                    self.data(data);
                }
            });
        }

        $imports.initComponent = function() {
            read();
        }
    }

    return PersonsSelectComponent;
});
            </code-highlight>
        </p>
        <p>
            Y la vista:
            <code-highlight language="HTML">
&lt;quark-component&gt;
    &lt;select class="form-control"
               data-bind="options: data,
                          optionText: 'name',
                          optionValue: 'id',
                          value: model.value"&gt;

    &lt;/select&gt;
&lt;/quark-component&gt;
            </code-highlight>
        </p>
        <p>
            Dicho componente representa un selector de personas que se obtienen mediante <code>AJAX</code>
            desde la url <code>http://example.com/persons</code>, el combo muestra el apellido y en el observable
            valor setea el id de la persona elegida.
        </p>
        <p>
            Considere que se necesita tambien hacer un listado de personas tomandolas del mismo servicio.
            Esto se podria implementar como:
            <code-highlight>
define(['quark', 'knockout', 'text!list.component.html'], function($$, ko, template) {
    function ListComponent(params, $scope, $imports) {
        var self = this;

        $$.parameters({
            value: ko.observable()
        }, params, this);

        $scope.data = ko.observableArray();

        function read() {
            $$.ajax('http://example.com/persons', 'GET', {}, {
                onSuccess: function(data) {
                    self.data(data);
                }
            });
        }

        $imports.initComponent = function() {
            read();
        }
    }

    return $$.component(ListComponent, template);
});
            </code-highlight>
        </p>
        <p>
            Y la vista:
            <code-highlight language="HTML">
&lt;quark-component&gt;
    &lt;table class="table table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;
                    Id
                &lt;/th&gt;
                &lt;th&gt;
                    Nombre
                &lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody data-bind="foreach: data"&gt;
            &lt;tr&gt;
                &lt;td data-bind="text: id"&gt;&lt;/td&gt;
                &lt;td data-bind="text: nombre"&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
    &lt;/table&gt;
&lt;/quark-component&gt;
            </code-highlight>
        </p>
        <p>
            Como se puede observar ambos componentes tienen identico modelo, y lo que es peor
            ambos invocan a exactamente el mismo servicio obteniendo los mismos datos en ambos casos.
            Considere lo que sucederia si se adapta el ejemplo del listado para mostrar el componente
            <code>select-persons</code> en cada fila del listado para definir por ejemplo que persona es el padre de cada uno.
            Queando la vista por ejemplo:
            <code-highlight language="HTML">
&lt;quark-component&gt;
    &lt;table class="table table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;
                    Id
                &lt;/th&gt;
                &lt;th&gt;
                    Nombre
                &lt;/th&gt;
                &lt;th&gt;
                    Padre
                &lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody data-bind="foreach: data"&gt;
            &lt;tr&gt;
                &lt;td data-bind="text: id"&gt;&lt;/td&gt;
                &lt;td data-bind="text: nombre"&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;select-persons data-bind="value: father"&gt;
                    &lt;/select-persons&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
    &lt;/table&gt;
&lt;/quark-component&gt;
            </code-highlight>
        </p>
        <p>
            En este ejemplo, por cada registro que haya en el listado de personas se invocará al
            servicio REST para llenar cada uno de los combos que se muestre lo cual causará seguramente
            problemas de performance y un tráfico de red innecesario.
        </p>
        <p>
            Lo mejor en este caso es migrar la logica de la consulta a un servicio, y luego compartir
            un contexto de servicios entre todos los componentes.
        </p>
        <p>
            Un servicio es en definitiva un modulo web que debe devolver la clase del servicio,
            dicha clase recibe como parametro el contexto en donde se creó, por ejemplo, el archivo
            <code>services/persons.service.js</code> quedaría como:
            <code-highlight>
define(['quark', 'knockout'], function($$, ko) {
    function PersonsService(context) {
        var self = this;

        this.querying = ko.observable(false);
        this.data = ko.observableArray();

        this.readPersons = function(genero) {

            var url = 'http://example.com/persons';

            if ($$.isDefined(genero)) {
                url += "?genero=" + genero;
            }

            self.querying(true);

            $$.ajax(url, 'GET', {}, {
                onSuccess: function(data) {
                    self.data(data);
                },
                onComplete: function() {
                    self.querying(false);
                }
            });
        }
    }

    return PersonsService;
});
            </code-highlight>
        </p>
        <p>
            Como se puede observar se ha migrado la lógica de la consulta REST al servicio.
            Una vez definido el servicio se debe registrar en <u>Require</u>, por ejemplo,
            modificando su require.config.js quedaría así:
            <code-highlight>
var require;
require = requireConfigure(QuarkRequireConf());
require = requireConfigure(require, {
    paths: {
        'bootstrap':        'bower_components/bootstrap/dist/js/bootstrap.min',
    },
    shim: {
        bootstrap: ['jquery']
    },
    config: {
        services: {
            PersonsService: "services/persons"
        }
    }
});
            </code-highlight>
        </p>
        <p>
            Notese que se define un nombre para la clase y se especifica donde se encuentra el
            servicio sin poner <code>.service.js</code>, <em>Quark.js</em> se lo agregará automáticamente.
        </p>
        <p>
            Se modifica el modelo del componente <code>persons-combo</code> para utilizar el servicio
            creado:
            <code-highlight>
define([
    'quark',
    'knockout',
    'text!select.component.html',
    'service!PersonsService'
], function($$, ko, template) {
    function PersonsSelectComponent(params, $scope, $imports, context) {
        var self = this;

        var service = context.get('PersonsService');

        $$.parameters({
            value: ko.observable()
        }, params, this);

        $scope.data = service.data;

        $imports.initComponent = function() {
            if (self.data().length == 0 &and;&and; !service.querying()) {
                service.readPersons();
            }
        }
    }

    return PersonsSelectComponent;
});
            </code-highlight>
        </p>
        <p>
            Lo primero que se hace es notificar a <em>Require</em> que se va a utilizar el
            servicio dentro del componente. Para esto se indica <code>service!</code> y el nombre
            del componente en la definicion del modulo. Esto hace que si el <em>Javascript</em>
            con la definicion del servicio no se ha cargado aun, se cargue.
        </p>
        <p>
            Luego se extrae el servicio del contexto utilizando la funcion <code>get</code> y
            especificando el nombre del servicio deseado. Si exitia en el contexto un servicio
            con ese nombre devuelve el servicio existente, y sino crea uno nuevo.
        </p>
        <p>
            Como se puede ver, la propiedad del <code>scope</code> donde se ponian los datos
            del combo ahora se toma del servicio, y en el metodo <code>initComponente</code>
            se verifica si hay datos o se está consultando el servicio, sino se llama al metodo
            para obtener dichos datos. Esto lo que hace es que cuando un componente invoca al metodo
            y llena los datos en el servicio, todos los componentes que compartan el servicio
            a través del contexto utilizarán la mismo a información limtando los request a los
            servicios REST a uno.
        </p>
        <p>
            Para completar el ejemplo restaría modificar la vista del componente lista para
            compartir su contexto con todos los componente <code>persons-select</code>:
            <code-highlight language="HTML">
&lt;quark-component&gt;
    &lt;table class="table table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;
                    Id
                &lt;/th&gt;
                &lt;th&gt;
                    Nombre
                &lt;/th&gt;
                &lt;th&gt;
                    Padre
                &lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody data-bind="foreach: data"&gt;
            &lt;tr&gt;
                &lt;td data-bind="text: id"&gt;&lt;/td&gt;
                &lt;td data-bind="text: nombre"&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;select-persons data-bind="value: father,
                                                  context: context"&gt;
                    &lt;/select-persons&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
    &lt;/table&gt;
&lt;/quark-component&gt;
            </code-highlight>
        </p>
        <p>
            En el ejemplo puede verse como se pasa la propiedad del scope <code>context</code>
            (que contiene el contexto del componente persons-list) a los componentes <code>persons-selector</code>
            a través del parametro <code>context</code>. Esto hace que todas las instancias de
            <code>persons-select</code> compartan el contexto entre sí y con <code>persons-list</code>
        </p>
        <p>
            Puede haber casos en donde se desee crear mas contextos manualmente, por ejemplo si se utiliza
            el mismo servicio para distintos sets de componentes.
        </p>
        <p>
            Considere el caso en que se modifica el servicio para obtener el listado de padres y madres y
            se desea agregar una columna mas en el componente <code>persons-list</code> para que muestre
            un select que permita elegir la madre de cada persona.
        </p>
        <p>
            En este caso necesitaríamos contar con el mismo servicio pero en tres conjuntos distintos.
            <ul>
                <ol>
                    Un set para mostrar todas las personas del listado
                </ol>
                <ol>
                    Un set para llenar los select de padres
                </ol>
                <ol>
                    Un set para llenar los select de madres
                </ol>
            </ul>
            Se modifica el modelo de <code>persons-list</code> para tener en cuenta esto:
            <code-highlight>
define([
    'quark',
    'knockout',
    'text!select.component.html',
    'service!PersonsService'
], function($$, ko, template) {
    function PersonsListComponent(params, $scope, $imports, context) {
        var self = this;

        var service = context.get('PersonsService');

        $scope.contextPadres = $$.serviceContext();
        $scope.contextMadres = $$.serviceContext();

        $$.parameters({
            value: ko.observable()
        }, params, this);

        $scope.data = service.data;

        $imports.initComponent = function() {
            if (self.data().length == 0 &and;&and; !service.querying()) {
                service.readPersons();
            }

            var servicePadres = $scope.contextPadres.get('PersonsService');
            var serviceMadres = $scope.contextMadres.get('PersonsService');

            servicePadres.readPersons('M');
            serviceMadres.readPersons('F');
        }
    }

    return PersonsListComponent;
});
            </code-highlight>
        </p>
        <p>
            En el ejemplo se crean dos nuevos contextos y dentro de cada uno se obtiene un servicio
            <code>PersonsService</code> luego se llenan los datos de un servicio con personas del genero
            masculino y el otro con personas del genero femenino.
            Solo resta compartir cada contexto con el conjunto de componentes correspondiente,
            para esto se modifica la vista de la siguiente manera:
            <code-highlight language="HTML">
&lt;quark-component&gt;
    &lt;table class="table table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;
                    Id
                &lt;/th&gt;
                &lt;th&gt;
                    Nombre
                &lt;/th&gt;
                &lt;th&gt;
                    Padre
                &lt;/th&gt;
                &lt;th&gt;
                    Madre
                &lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody data-bind="foreach: data"&gt;
            &lt;tr&gt;
                &lt;td data-bind="text: id"&gt;&lt;/td&gt;
                &lt;td data-bind="text: nombre"&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;select-persons data-bind="value: father,
                                                  context: contextPadres"&gt;
                    &lt;/select-persons&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;select-persons data-bind="value: father,
                                                  context: contextMadres"&gt;
                    &lt;/select-persons&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
    &lt;/table&gt;
&lt;/quark-component&gt;
            </code-highlight>
        </p>
        <p>
            Como el componente <code>persons-list</code> ya les pasa un contexto que contiene
            el servicio con los datos precargados, los componentes se llenan con los datos correspondientes
            de cada contexto.
        </p>
        <nav-next-prev params="previousText: 'Virtual', previousPage: 'main/docs/basics-virtual',
                               nextText: 'Módulos', nextPage: 'main/docs/basics-modules'">

        </nav-next-prev>
    </span>
