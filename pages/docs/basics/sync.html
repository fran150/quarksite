<!-- quark-component -->
    <span class="docs">
        <h1>Sincronización</h1>
        <hr />
        <p>
            El proposito de este capitulo es describir el orden de carga y ejecución de los distintos elementos que forman
            una aplicación en <em>Quark.js</em> y luego presentar algunas herramientas que permiten sincronizar la ejecución
            del código cuando sea necesario.
        </p>
        <p>
            <h3>Al iniciar la aplicación:</h3>
            <hr/>
            <ol>
                <li>
                    Se carga la página principal y punto de entrada, el navegador al detectar los tags
                    script que incluyen <em>Quark.js</em> y <em>Require</em> carga y ejecuta esos scripts.
                </li>
                <li>
                    Entre los script de inicio se ejecuta el que configura require.js con todos los modulos de <em>Quark.js</em>
                    y luego ejecuta el modulo inicial de la aplicación.
                </li>
                <li>
                    En el modulo inicial se deben registrar todos los componentes, configurar las páginas y rutas y ejecutar
                    la función <code>activateHasher</code> del objeto <code>routing</code> de <em>Quark.js</em> para iniciar el
                    sistema de ruteo y <code>start</code> para iniciar la aplicación.
                </li>
                <li>
                    Si se especificó una función custom al activar el sistema de ruteo con la función <code>activateHasher</code>
                    se ejecuta dicha función que finalmente deberá invocar a la función <code>parse</code> del objeto
                    <code>routing</code> pasándole el hash.
                </li>
                <li>
                    <em>Quark.js</em> parsea la ruta y continúa al proximo punto, paralelamente y en forma asíncronica por cada segmento :
                    <ol>
                        <li>
                            Carga y ejecuta el controlador correspondiente pasando como parámetro el controlador
                            padre y el <code>tracker</code>.
                        </li>
                        <li>
                            Crea la propiedad parent en el controlador asignandole el controlador padre.
                        </li>
                        <li>
                            Crea la propiedad outlets en el controlador creando por cada outlet definido en el segmento una propiedad
                            y asignandole el nombre del componente a mostrar.
                        </li>
                        <li>
                            Crea la propiedad params en el controlador creando por cada parametro definido en el segmento de la
                            página una propiedad y asginandole un observable inicializado al valor definido.
                        </li>
                        <li>
                            Se evalua el valor de cada parametro de la ruta y se le asigna al parametro con el mismo nombre
                            que se haya definido en el controlador.
                        </li>
                        <li>
                            Al finalizar la carga y configuración de todos los controladores se setea el observable
                            <code>routing.current</code> con el nombre de la página actual indicando la finalización del ruteo
                        </li>
                    </ol>
                </li>
                <li>
                    Al ejecutarse <code>start</code>, si se especificó un modelo se ejecuta dicho modelo y se procede a
                    realizar el binding del mismo con la página principal.
                </li>
                <li>
                    Al realizarse el binding de cada <code>outlet</code>:
                    <ol>
                        <li>
                            Busca en el arbol de controladores el ultimo que contenga en el objeto
                            <code>outlets</code> una propiedad con el mismo nombre del outlet y obtiene el tag del componente
                            que se debe mostrar. Si no se encuentra ninguna se utiliza el componente "empty" que
                            es un componente vacío.
                        </li>
                        <li>
                            Verifica si el controlador contiene un método <code>sendParameters</code> y en tal caso lo
                            invoca para obtener los parametros del componente asociado al outlet.
                        </li>
                        <li>
                            Realiza el binding del componente pasándole los parametros obtenidos.
                        </li>
                    </ol>
                </li>
            </ol>

            <h3>Al cambiar de página</h3>
            <hr/>
            Al cambiar de página <em>Quark.js</em> primero intentará limpiar los objetos de la ruta anterior, tanto los
            componentes como los controladores.
            <ol>
                <li>
                    Compara la ruta anterior con la nueva y por cada segmento distinto recorre los controladores de la ruta
                    anterior:
                    <ol>
                        <li>
                            Setea el componente generico <code>empty</code> en la propiedad <code>outlets</code> de
                            cada controlador, permitiendo que se descargue el componente que se encontraba cargado en dicho
                            outlet.
                        </li>
                        <li>
                            Si el controlador tiene un metodo <code>dispose</code> lo ejecuta permitiendo que libere todos los
                            recursos que tenga tomados
                        </li>
                        <li>
                            Finalmente, elimina la referencia al controlador.
                        </li>
                    </ol>
                </li>
                <li>
                    Por cada segmento nuevo en la ruta realiza la carga de los controladores y componentes relacionados
                    tal y como se describió en el apartado anterior, a saber:
                    <ol>
                        <li>
                            Carga y ejecuta el controlador correspondiente pasando como parámetro el controlador
                            padre y el <code>tracker</code>.
                        </li>
                        <li>
                            Crea la propiedad parent en el controlador asignandole el controlador padre.
                        </li>
                        <li>
                            Crea la propiedad outlets en el controlador creando por cada outlet definido en el segmento una propiedad
                            y asignandole el nombre del componente a mostrar.
                        </li>
                        <li>
                            Crea la propiedad params en el controlador creando por cada parametro definido en el segmento de la
                            página una propiedad y asginandole un observable inicializado al valor definido.
                        </li>
                        <li>
                            Se evalua el valor de cada parametro de la ruta y se le asigna al parametro con el mismo nombre
                            que se haya definido en el controlador.
                        </li>
                        <li>
                            Al finalizar la carga y configuración de todos los modulos se setea el observable
                            <code>routing.current</code> con el nombre de la página actual indicando la finalización del ruteo
                        </li>
                    </ol>
                    Igualmente al cargar cada outlet que tengan los componentes definidos en la nueva ruta:
                    <ol>
                        <li>
                            Busca en el arbol de controladores el ultimo que contenga en el objeto
                            <code>outlets</code> una propiedad con el mismo nombre del outlet y obtiene el tag del componente
                            que se debe mostrar. Si no se encuentra ninguna se utiliza el componente "empty" que
                            es un componente vacío.
                        </li>
                        <li>
                            Verifica si el controlador contiene un método <code>sendParameters</code> y en tal caso lo
                            invoca para obtener los parametros del componente asociado al outlet.
                        </li>
                        <li>
                            Realiza el binding del componente pasándole los parametros obtenidos.
                        </li>
                    </ol>
                </li>
                <li>
                    Una vez eliminados todos los componentes y controladores de la ruta anterior, y cargados los nuevos
                    controladores setea el nuevo valor de la pagina actual en <code>routing.current</code>
                </li>
            </ol>

            <h3>Al cargar un componente</h3>
            <hr/>
            Cuando se está realizando el binding de un elemento y se detecta un <em>tag</em> customizado:
            <ol>
                <li>
                    <em>Knockout</em> verifica entre los componentes que tiene registrados a ver si alguno corresponde
                    con el <em>tag</em> encontrado.
                </li>
                <li>
                    Si se encontró un componente con dicho <em>tag</em>, se procede a cargar y ejecutar el modulo web
                    con el modelo del componente pasandole el valor los parametros definidos para el componente, el
                    <em>scope</em> y el <code>tracker</code>.
                </li>
                <li>
                    Una vez cargado y ejecutado el modelo, si se definió un método <code>initComponent</code> en el tracker
                    se ejecuta dicho metodo donde se puede inicializar el componente.
                </li>
                <li>
                    Se crea la propiedad <code>model</code> e <code>imports</code> en el scope con el componente, con el modelo
                    y el <code>tracker</code> respectivamente.
                </li>
                <li>
                    Se procede a realizar el binding del scope con la vista.
                </li>
                <li>
                    Si se encuentra un <em>tag</em> customizado se repiten estos pasos para cargar el componente nuevo,
                    si dicho componente posee un binding <code>imports</code>:
                    <ol>
                        <li>
                            Al comenzar finalizar la carga y el binding del nuevo componente se dispara la señal
                            <code>loaded</code> en el <code>tracker</code> del padre pasándole el nombre con el que
                            se importó y el modelo.
                        </li>
                        <li>
                            Una vez que el nuevo componente pase al estado <em>Listo</em> se dispara la señal
                            <code>readied</code> en el <code>tracker</code> del padre pasándole el nombre con el que
                            se importó y el modelo y se evalúa si todas las dependencias estan listas, en este caso
                            se habilita el <code>lock</code> ready indicando que el componente está listo.
                        </li>
                    </ol>
                </li>
            </ol>
        </p>
    </span>
<!-- /quark-component -->
